= Notions de Transact SQL
Timoth√©e Robert
:doctype: article
:encoding: utf-8
:lang: fr
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: rouge
:rouge-style: github

// -- PARTIE 1 : COURS --

== Introduction

[OBJECTIFS]
====
L'√©tude des d√©clencheurs (triggers) est mise en avant dans le r√©f√©rentiel du BTS SIO SLAM comme une solution de *d√©fense en profondeur* c√¥t√© serveur.
Le pr√©requis pour aborder les d√©clencheurs est la ma√Ætrise des proc√©dures stock√©es, qui elle-m√™me repose sur la connaissance de Transact SQL (T-SQL).
====

image::images/transact.png[Sch√©ma montrant que les d√©clencheurs sont un sous-ensemble des proc√©dures stock√©es, elles-m√™mes comprises dans Transact SQL]

=== Qu'est-ce que le Transact SQL ?

Transact SQL est une **extension du langage SQL** propri√©taire √† Microsoft SQL Server. Sa connaissance est indispensable pour aborder les notions de l'√©preuve E6 sur la Cybers√©curit√©, notamment les d√©clencheurs.

Le T-SQL permet notamment de :

* Ex√©cuter des instructions SQL en mode interactif ou par lots (batch).
* Programmer des proc√©dures stock√©es.
* Programmer des d√©clencheurs (triggers).

== Instructions de base T-SQL

=== Organisation du code

`GO`::
Force l'ex√©cution des instructions pr√©c√©dentes en un seul lot.

`USE database_name`::
Permet de s√©lectionner la base de donn√©es sur laquelle travailler. C'est un r√©flexe √† avoir pour ne pas impacter les bases des autres.

`-- Commentaire sur une ligne`::
Les deux tirets permettent un commentaire monoligne.

`/* Commentaire sur plusieurs lignes */`::
Permet d'√©crire des blocs de commentaires.

`BEGIN...END`::
D√©limite un bloc d'instructions, par exemple dans une condition ou une boucle.

=== Affichage

La commande `PRINT` affiche une cha√Æne de caract√®res ou le contenu d'une variable dans la console de messages.

[source,sql]
----
-- Concat√©nation simple avec l'op√©rateur +
PRINT 'Le message √† afficher.';
PRINT 'Il y a ' + @ma_variable + ' √©l√©ments.';
----

=== Les variables

==== D√©claration : `DECLARE`

Toute variable en T-SQL doit √™tre d√©clar√©e avec `DECLARE` et son nom doit commencer par un arobase (`@`).

[source,sql]
----
DECLARE @nom_variable type_de_donnees;
DECLARE @compteur INT;
DECLARE @nom_eleve VARCHAR(50);
----

==== Affectation : `SET` et `SELECT`

`SET` et `SELECT` permettent toutes deux d'affecter une valeur √† une variable.

* **SET** est utilis√© pour affecter *une seule variable* √† la fois. C'est l'outil standard pour initialiser un compteur ou une valeur simple.
[source,sql]
----
DECLARE @compteur INT;
SET @compteur = 1;
SET @compteur = @compteur + 1;
----

* **SELECT** peut affecter *plusieurs variables en m√™me temps* et peut surtout r√©cup√©rer sa valeur directement depuis une requ√™te sur une table.
[source,sql]
----
DECLARE @nom_jeu VARCHAR(100), @prix_jeu DECIMAL(5,2);

-- R√©cup√®re le nom et le prix d'un jeu et les stocke dans des variables
SELECT @nom_jeu = nom, @prix_jeu = prix
FROM SOFTWARE.JEUX
WHERE id_jeu = 42;
----

NOTE: Si une requ√™te `SELECT` utilis√©e pour une affectation retourne plusieurs lignes, seule la **derni√®re ligne** est utilis√©e pour l'affectation des variables. La variable syst√®me `@@ROWCOUNT` contient le nombre de lignes affect√©es par la derni√®re instruction.

=== Structures de contr√¥le

==== Conditions : `IF...ELSE`

La structure est simple et ne n√©cessite pas de parenth√®ses pour la condition ni d'accolades pour les blocs. On utilise `BEGIN` et `END` pour les blocs de plus d'une instruction.

[source,sql]
----
IF @compteur > 10
BEGIN
    PRINT 'Le compteur a d√©pass√© 10.';
    -- Autre instruction...
END
ELSE
BEGIN
    PRINT 'Le compteur est inf√©rieur ou √©gal √† 10.';
END;
----

==== Boucles : `WHILE`

T-SQL n'a pas de boucle `FOR`. La boucle principale est `WHILE`.

[source,sql]
----
DECLARE @i INT = 1;
WHILE @i <= 10
BEGIN
    PRINT 'Ligne num√©ro ' + CAST(@i AS VARCHAR);
    SET @i = @i + 1;
END;
----

Les instructions `BREAK` (pour sortir de la boucle) et `CONTINUE` (pour passer √† l'it√©ration suivante) fonctionnent comme dans d'autres langages. L'instruction `GOTO` existe mais son usage est fortement d√©conseill√©.

=== Types personnalis√©s : `CREATE TYPE`

T-SQL permet de cr√©er ses propres types de donn√©es √† partir de types existants pour renforcer la coh√©rence du mod√®le.

[source,sql]
----
-- Cr√©e un type "email" bas√© sur un VARCHAR(255) qui ne peut pas √™tre nul.
CREATE TYPE type_email FROM VARCHAR(255) NOT NULL;
GO

-- Utilisation du type personnalis√© dans une d√©claration de variable
DECLARE @email_utilisateur type_email = 'test@example.com';
----

// -- PARTIE 2 : TRAVAUX PRATIQUES --

== Travaux Pratiques : Instructions de base T-SQL

=== Exo 1 : Instruction SELECT (Rappels)


Chargez et ex√©cutez le script `005 - Script creation table FormationEleves.sql`.

.Contenu du script de cr√©ation de la table FormationEleves
[source,sql]
----
include::scripts/005-Script cr√©ation table FormationEleves.sql[]
----
. Que font les instructions `DROP TABLE` et `DROP SCHEMA` (lignes 2 et 3) ?
. Dans quelle vue syst√®me de m√©tadonn√©es sont stock√©es les informations sur les sch√©mas ?
. Expliquez le reste du programme et ce qu'il affiche.

TIP: La question 2 vous invite √† utiliser l'explorateur d'objets de SSMS pour fouiller dans les vues syst√®mes (`sys.`).

=== Exo 2 : Variables et agr√©gats üìà

Le but est de manipuler des variables issues de calculs sur un ensemble de donn√©es, pas juste un simple comptage.

1.  Cr√©ez un programme qui calcule le **nombre d'heures de cours d'info moyen** des √©lves de la table `PROCS.FORMATIONELEVES` et stockez-le dans une variable nomm√©e `@nb_heures_moyen`.
2.  D√©clarez deux autres variables : `@nom_ecole_max_heures` (VARCHAR) et `@nb_heures_info_max` (DECIMAL).
3.  En une seule requ√™te `SELECT`, r√©cup√©rez le **nom** de l'√©cole avec le plus d'heures de cours d'info et le nombre d'heures d'info maximum.
4.  Affichez un message r√©capitulatif clair, par exemple : "Le nombre maximum d'heures d'info est de: nb_heures_info_max pour la formation: nom_ecole_max_heures ."

=== Exo 3 (Optionnel) : Cr√©ation d'un sous-type

Ex√©cutez le code du fichier `EXPL_Type_Utilisateur.sql`.
.Contenu du script EXPL_Type_Utilisateur.sql
[source,sql]
----
include::scripts/EXPL_Type_Utilisateur.sql[]
----

. Expliquez ce que fait ce code.
. O√π sont stock√©es ces informations de type dans SQL Server ? (Utilisez l'explorateur d'objets)
. Quelles fonctions sont utilis√©es et √† quoi servent-elles ?

=== Exo 4 : IF et validation de donn√©es üìß

Ici, on passe du tri de num√©ros de t√©l√©phone √† une validation de format plus proche d'un cas d'usage applicatif.

1.  Cherchez √† quoi servent les fonctions T-SQL **`CHARINDEX`** et/ou **`PATINDEX`**.
2.  D√©clarez une variable `@email` et affectez-lui une adresse de test (par ex: 'contact@monsite.fr').
3.  √âcrivez un script avec une structure `IF` qui v√©rifie si l'email est "a priori valide" selon les crit√®res suivants (cumulatifs) :
* L'adresse contient bien un caract√®re `@`.
* Il y a au moins un caract√®re `.` **apr√®s** le `@`.
4.  Affichez un message appropri√© selon que l'adresse passe le test ou non.
5.  Testez votre script en changeant la valeur de `@email` pour des cas invalides ('test.com', 'test@domaine', 'test@.com').

=== Exo 5 : Boucle WHILE et formatage de donn√©es üè≠

On quitte le calcul math√©matique abstrait pour une t√¢che concr√®te de g√©n√©ration de donn√©es format√©es.

√âcrivez un script qui simule la g√©n√©ration de 15 codes produits uniques pour un catalogue.

1.  Utilisez une boucle `WHILE` qui s'ex√©cutera 15 fois.
2.  √Ä chaque it√©ration, g√©n√©rez et affichez un code produit qui respecte le format suivant : **`PROD-2025-XX`**, o√π `XX` est le num√©ro de l'it√©ration.
3.  **Contrainte importante :** Le num√©ro `XX` doit toujours √™tre sur deux chiffres. `1` doit donc devenir `01`, `2` doit devenir `02`, etc. (Cela n√©cessitera un `IF` √† l'int√©rieur de la boucle).
4.  Ajoutez une condition : si le num√©ro de l'it√©ration est un multiple de 5, affichez √† c√¥t√© du code le message `(Lot de contr√¥le qualit√©)`.

=== Exo 6 : `BREAK`, `CONTINUE` et `GOTO`

Ex√©cutez et commentez (ajoutez des `--` pour expliquer ce que fait chaque ligne ou bloc) les 3 scripts ci-dessous pour bien comprendre leur fonctionnement.

==== Exemple `BREAK`
[source,sql]
----
DECLARE @telephone CHAR(14) = '06-74-85-14-44';
DECLARE @trouve    BIT      = 0;
DECLARE @indice    SMALLINT = 1;
BEGIN
 WHILE (@indice <= 14)
   BEGIN
    IF SUBSTRING(@telephone,@indice,1) = '4'
     BEGIN
      PRINT CONCAT('Trouv√© 4 √† l''indice : ',@indice);
      SET @trouve = 1;
     END;
    ELSE
      SET @indice = @indice+1;
    IF (@trouve=1) BREAK;
  END;
END;
----

==== Exemple `CONTINUE`
[source,sql]
----
DECLARE @telephone CHAR(14) = '06-74-85-14-44';
DECLARE @trouve    BIT      = 0;
DECLARE @indice    SMALLINT = 1;
BEGIN
 WHILE (@indice <= 14 AND @trouve=0)
   BEGIN
    IF SUBSTRING(@telephone,@indice,1) = '4'
     BEGIN
      PRINT CONCAT('Trouv√© 4 √† l''indice : ',@indice);
      SET @indice = @indice+1;
      CONTINUE;
      SET @trouve = 1; -- ne sera jamais atteint
     END;
    ELSE
      SET @indice = @indice+1;
  END;
END;
----

==== Exemple `GOTO`
[source,sql]
----
BEGIN
 DECLARE @compteur TINYINT  = 0;
 DECLARE @somme    SMALLINT = 0;
 avant:
 IF @compteur >= 10 GOTO apres;
 ELSE
  BEGIN
    SET @compteur = @compteur + 1;
    SET @somme    = @somme    + @compteur;
--    PRINT @compteur;
    GOTO avant;
  END;
 apres:
    PRINT 'Somme : '+CAST(@somme AS CHAR(4));
END;
----

==== Correction exo 2
[source,sql]
----
DECLARE @nb_heures_moyen INT

SELECT @nb_heures_moyen = AVG(NB_HEURES_COURS_INFO)
FROM PROCS.FORMATIONELEVES

PRINT 'En moyenne les √©l√®ves ont: '+CAST(@nb_heures_moyen AS VARCHAR)+' heures de cours en moyenne'

DECLARE @nom_ecole_max_heures VARCHAR(40)
DECLARE @nb_heures_info_max DECIMAL(10,2)

/* SELECT TOP 1 @nb_heures_info_max=NB_HEURES_COURS_INFO , @nom_ecole_max_heures=CODE_FILIERE
FROM PROCS.FORMATIONELEVES */
SELECT TOP 1 @nb_heures_info_max=SUM(NB_HEURES_COURS_INFO) , @nom_ecole_max_heures=CODE_FILIERE
FROM PROCS.FORMATIONELEVES
GROUP BY CODE_FILIERE
ORDER BY SUM(NB_HEURES_COURS_INFO)

PRINT 'Le nombre maximum d heures d nfo est de: '+CAST(@nb_heures_info_max AS VARCHAR)+' pour la formation: '+CAST(@nom_ecole_max_heures AS VARCHAR)
----
==== Correction exo 3
[source,sql]
----
DECLARE @email VARCHAR(64) = 'contact@monsite.fr';

DECLARE @arobasque_dans_email INT ;
DECLARE @point_apres_arobasque INT ;

SELECT @arobasque_dans_email = CHARINDEX('@', @email);
SELECT @point_apres_arobasque = CHARINDEX('.', @email,@arobasque_dans_email+1);


IF @arobasque_dans_email > 1 -- pas de '@' en premi√®re position
   AND @point_apres_arobasque > @arobasque_dans_email + 1 -- il y a au moins un caract√®re entre '@' et '.'
   AND @point_apres_arobasque < LEN(@email) -- le '.' n'est pas le dernier caract√®re
   AND CHARINDEX('@', @email, @arobasque_dans_email + 1) = 0 -- un seul '@'
   AND @point_apres_arobasque IS NOT NULL
PRINT 'L email est Ok' ;
ELSE
PRINT 'L email est Ko' ;
----

==== Correction exo 4
[source,sql]
----
DECLARE @code_produit VARCHAR(60) = 'PROD-2025-'
DECLARE @compteur INT = 1

WHILE @compteur <= 15
BEGIN
IF @compteur % 5 = 0
PRINT @code_produit+FORMAT(@compteur,'00')+'(Lot de contr√¥le qualit√©)'
ELSE PRINT @code_produit+FORMAT(@compteur,'00')

SET @compteur = @compteur +1
END
----