= Séquence Pédagogique : Les Déclencheurs (Triggers)
:toc: left
:icons: font
:sectnums:
:source-highlighter: pygments

// Métadonnées du cours
:author: Professeur (BTS SIO2)
:description: Cours et exercices sur les déclencheurs (SQL Server et MySQL).
:keywords: SQL Server, MySQL, Trigger, Déclencheur, LMD, LDD, SIO, Défense en Profondeur

== Introduction et Contexte

Nous avons déjà examiné les procédures stockées et les fonctions (UDF).
Cette séquence aborde les **déclencheurs (triggers)**, un troisième type de routine SQL.
Un déclencheur est un sous-programme (similaire à une procédure stockée) qui est **automatiquement exécuté** en réponse à un **événement** spécifique survenant dans la base de données.

=== Le Concept de "Défense en Profondeur"

Dans le contexte du BTS SIO, les déclencheurs sont souvent présentés comme une solution de **"défense en profondeur"** côté serveur.
L'idée est de garantir l'intégrité et la traçabilité des données directement au niveau de la base, quel que soit l'applicatif qui s'y connecte, pour faire face aux menaces (compromission, injection, accès non autorisé).

.Cas d'usage typique (Sécurité/Traçabilité)
Un déclencheur peut intercepter un `DELETE` sur une table sensible et enregistrer qui a supprimé quoi et quand dans une table de logs (audit).
Cela garantit la traçabilité même si l'application n'a pas prévu cette fonctionnalité.

== Les Principaux Types de Déclencheurs

On distingue trois grandes familles d'événements pouvant activer un déclencheur.

* **Déclencheurs LMD (Langage de Manipulation de Données)** :
Les plus courants. Ils réagissent aux événements `INSERT`, `UPDATE`, ou `DELETE` sur une table ou une vue spécifique.
* **Déclencheurs LDD (Langage de Définition de Données)** :
Ils réagissent aux événements qui modifient la structure de la base ou du serveur, tels que `CREATE_TABLE`, `ALTER_INDEX`, `DROP_VIEW`. Très utiles pour les pistes d'audit.
* **Déclencheurs de Connexion (Logon)** :
Un type spécifique qui se déclenche lorsqu'un utilisateur ouvre une session sur le serveur (`LOGON`).

NOTE: Il n'existe pas de déclencheur natif sur l'événement `SELECT`. Pour auditer les lectures, il faut utiliser les fonctionnalités d'Audit SQL Server.

== Partie 1 : Déclencheurs sur SQL Server (Transact-SQL)

Nous commençons par l'implémentation sur Microsoft SQL Server.

=== Syntaxe Générale (T-SQL)

La syntaxe de base pour un déclencheur LMD est la suivante:

[source,sql]
----
CREATE [ OR ALTER ] TRIGGER [ nom_schema . ] nom_trigger
ON { nom_table | nom_vue }
[ WITH <options> ]
{ FOR | AFTER | INSTEAD OF }
{ [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] }
AS
BEGIN
    -- Logique du déclencheur
    -- (Instructions Transact-SQL)
END;
----

* `AFTER` (ou `FOR`) : Le déclencheur s'exécute *après* l'action LMD. C'est le comportement le plus courant pour l'audit ou la validation.
* `INSTEAD OF` : Le déclencheur s'exécute *à la place* de l'action LMD. Très utilisé pour permettre les mises à jour sur des vues basées sur plusieurs tables.

=== Les Pseudo-Tables : `inserted` et `deleted`

Pendant l'exécution d'un déclencheur LMD T-SQL, le SGBD expose deux tables temporaires spéciales, en lecture seule:

* `inserted` : Contient les **nouvelles lignes**
** `INSERT` : contient les lignes qui viennent d'être ajoutées.
** `UPDATE` : contient les lignes *après* la modification (les nouvelles valeurs).
* `deleted` : Contient les **anciennes lignes**
** `DELETE` : contient les lignes qui viennent d'être supprimées.
** `UPDATE` : contient les lignes *avant* la modification (les anciennes valeurs).

Ces tables sont essentielles pour savoir *quelles données* ont été affectées par l'événement.

=== Cas d'Usage LMD (AFTER)

.Exemple 1 : Audit simple (trg_AfterInsert_Employee)
L'objectif est de remplir une table `EmployeeAudit` à chaque fois qu'un nouvel employé est ajouté.

[source,sql]
----
CREATE OR ALTER TRIGGER trg_AfterInsert_Employee
ON Employee
AFTER INSERT
AS
BEGIN
    INSERT INTO EmployeeAudit (EmployeeID, Operation, OperationDate)
    SELECT EmployeeID, 'INSERT', GETDATE()
    FROM INSERTED;
END;
----

.Exemple 2 : Validation complexe (Format Numéro Téléphone)
L'objectif est de forcer un format `XX-XX-XX-XX-XX` pour le `NUMERO_TELEPHONE`.

[source,sql]
----
CREATE TRIGGER trg_VERIFIE_NUMERO_TELEPHONE
ON CLIENTS
AFTER INSERT, UPDATE
AS
BEGIN
    IF EXISTS (
        SELECT * FROM INSERTED
        WHERE NUMERO_TELEPHONE NOT LIKE '[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]')
    BEGIN
        RAISERROR ('Le numéro de téléphone doit être au format XX-XX-XX-XX-XX.', 16, 1);
        ROLLBACK TRANSACTION;
    END;
END;
----

.Exemple 3 : Historisation (Mer et Soleil)
L'objectif est d'archiver toute location supprimée de la table `Location` vers la table `HistoLoc`.

[source,sql]
----
CREATE OR ALTER TRIGGER MERSOLEIL.HistoLocation
ON MERSOLEIL.Location
FOR DELETE
AS
INSERT INTO MERSOLEIL.HistoLoc (DateHisto,Numloc, NumSem, NumStu, NumCli, Regle, PrixLoc)
SELECT GetDate(),Numloc, NumSem, NumStu, NumCli, Regle, PrixLoc
FROM deleted
----

.Exemple 4 : Validation métier (Limite de compétences)
L'objectif est d'empêcher l'ajout de plus de 4 langages pour un élève.

[source,sql]
----
CREATE OR ALTER TRIGGER PROCS.E_CMP_I_LANGUEINF
ON PROCS.COMPETENCES_LANGAGE_INFO AFTER INSERT AS
BEGIN
    DECLARE @NBLANG INT ;
    SELECT @NBLANG = NB_LANGAGE_INFO FROM PROCS.FORMATIONELEVES
    WHERE ID_ELEVE=(SELECT ID_ELEVE FROM INSERTED) ;
    IF @NBLANG < 4
        UPDATE PROCS.FORMATIONELEVES
            SET NB_LANGAGE_INFO = NB_LANGAGE_INFO + 1
            WHERE ID_ELEVE=(SELECT ID_ELEVE FROM INSERTED) ;
    ELSE
        BEGIN
        ROLLBACK TRANSACTION ;
        THROW 50002, 'L élève a déjà la maitrise de 4 langages info',1;
        END;
END;
----

=== Cas d'Usage LMD Avancé (INSTEAD OF)

Les triggers `INSTEAD OF` sont souvent utilisés sur des vues pour "traduire" une opération (comme un `INSERT`) en plusieurs opérations sur les tables de base sous-jacentes.

== Partie 2 : Déclencheurs LDD (SQL Server)

Ces déclencheurs surveillent les modifications de la *structure* de la base.

.Exemple : Audit des modifications de structure
Ce trigger se déclenche `ON DATABASE` pour les événements `DROP_TABLE`, `DROP_INDEX`, `ALTER_TABLE`.
Il loggue l'événement dans une table `evenements` et peut annuler l'action (par exemple le week-end).

== Partie 3 : Déclencheurs de Connexion (SQL Server)

Ces triggers s'exécutent sur l'événement `LOGON` et sont définis au niveau du **serveur**.
Ils permettent par exemple de limiter les connexions à certaines heures.

== Partie 4 : TP SQL Server

=== TP 1 : Étude de Cas "Mer et Soleil"

* **Contexte**: Gestion de locations. Le `CA` est un champ dénormalisé dans `CLIENT` qui doit être maintenu. `HISTOLOC` archive les suppressions.
* **Données**: Script `Données Mer et Soleil.sql`

* **Exercice 1**:
1.  *Initialisation*: Mettre à jour le champ `CA` de `CLIENT` pour qu'il reflète la somme des `PrixLoc` existants.
2.  *Formatage*: Modifier le trigger `NomEnMaj` pour `NomCli` en `UPPER` et `PrenomCli` avec `Initiale en Majuscule`.
3.  *Historisation*: Tester le trigger `HistoLocation` (vu dans les exemples) lors d'un `DELETE` sur `Location`.
4.  *MAJ du CA*: Créer un **nouveau déclencheur** sur `LOCATION` (pour `INSERT`, `UPDATE`, `DELETE`) qui met à jour le `CA` du client correspondant dans la table `CLIENT` en temps réel.

=== TP 2 : "Formation des Élèves"

* **Contexte**: Gérer les compétences et méthodes des élèves.
* **Données**: Script `Exemple Trigger Insert et Delete.sql` (contient le setup et le premier trigger).

* **Exercice 1**:
1.  Tester le trigger `E_CMP_I_LANGUEINF` (vu en cours) jusqu'à ce qu'il bloque l'insertion.
2.  Ajouter une table `COMPETENCE_METHODE` (AGILE, UML, GIT, DEVOPS...) avec une clé étrangère vers l'élève.
3.  Créer un nouveau trigger sur `COMPETENCE_METHODE` empêchant l'insertion au-delà de 2 méthodes par élève.

=== TP 3 : "Compagnie Aérienne" (Brouard)

* **Contexte**: Gestion des pilotes et de leurs qualifications. La table `T_pilote_pil` contient un champ dénormalisé `pil_nbqualif` qui compte les qualifications de `T_qualifs_qua`.
* **Données**: Script `DOC2-15 - Déclencheurs livre Brouard SQL Server.sql`

* **Exercice 1 : Déclencheur `AFTER DELETE`**
* *Objectif*: Quand on supprime une qualification (`DELETE` sur `T_qualifs_qua`), décrémenter le compteur `pil_nbqualif` du pilote concerné dans `T_pilote_pil`.

* **Exercice 2 : Déclencheur `AFTER INSERT`**
* *Objectif*: Quand on ajoute une qualification (`INSERT` sur `T_qualifs_qua`), incrémenter `pil_nbqualif`.
* *Règle métier*: Un pilote ne peut pas avoir plus de 3 qualifications. Si la limite est atteinte, annuler la transaction (`ROLLBACK`).

* **Exercice 3 : Déclencheur `AFTER UPDATE`**
* *Objectif*: Gérer la mise à jour du `pil_brevet` (changement de pilote pour une qualification).
* *Règles métier*:
1.  Annuler si on change le `typ_typa` (modification interdite).
2.  Annuler si le *nouveau* pilote dépasse 3 qualifications.

== Partie 5 : Déclencheurs sur MySQL

L'implémentation des déclencheurs varie entre les SGBD. L'étude de cas "Easy2Drive" utilise MySQL.

=== Différences Clés : SQL Server vs MySQL

* **Pseudo-Tables** :
* *SQL Server* utilise `inserted` et `deleted` (tables).
* *MySQL* utilise les alias `NEW` et `OLD` (ligne en cours).
* **Syntaxe** :
* *MySQL* nécessite `DELIMITER $$`.
* *MySQL* utilise `IF ... THEN ... END IF;`.
* *MySQL* utilise `SIGNAL SQLSTATE` pour les erreurs.

=== Syntaxe Générale (MySQL)

[source,mysql]
----
CREATE TRIGGER trigger_name
{ BEFORE | AFTER } { INSERT | UPDATE | DELETE }
ON tbl_name FOR EACH ROW
trigger_body
----

== Partie 6 : Étude de Cas MySQL "Easy2Drive"

=== Contexte et Mission

L'audit de sécurité de la plateforme "Easy2Drive" a révélé des risques, notamment "l'attribution abusive de la Garantie Réussite".
Un déclencheur `check_garantie_reussite` est déjà en place pour contrôler les conditions lors de l'enregistrement de l'échec.

=== Conditions d'attribution de la "Garantie Réussite"

L'élève doit:
1.  Avoir passé au moins 25 séries de quiz.
2.  Avoir passé au moins 4 examens blancs.
3.  Avoir obtenu au moins 34/40 de moyenne sur les 4 meilleurs examens blancs.
4.  L'échec doit dater de moins de 6 mois.
5.  La garantie n'est accordée qu'une seule fois après le premier échec.

=== Code du Déclencheur Existant

[source,mysql]
----
DELIMITER $$
CREATE TRIGGER IF NOT EXISTS check_garantie_reussite
BEFORE UPDATE
ON Eleve
FOR EACH ROW
BEGIN
    DECLARE v_nbSerie INT;
    DECLARE v_scoreMoyen DOUBLE;

    -- Gérer condition 5 (deuxième échec)
    IF OLD.echecEtg = 1 AND NEW.echecEtg = 1 THEN
        SIGNAL SQLSTATE '10001' SET MESSAGE_TEXT = 'Garantie réussite : deuxième échec';
    END IF ;

    -- Gérer condition 4 (échec trop ancien)
    IF DATE_ADD(NEW.dateEtg, INTERVAL 6 MONTH) >= NOW() THEN
        SIGNAL SQLSTATE '10002' SET MESSAGE_TEXT = 'Garantie réussite : échec trop ancien';
    END IF ;

    -- Gérer condition 1 (nb séries)
    SELECT COUNT(*) INTO v_nbSerie FROM Evaluer WHERE idEleve = NEW.idUtilisateur;
    IF v_nbSerie < 25 THEN
        SIGNAL SQLSTATE '10003' SET MESSAGE_TEXT = 'Garantie réussite : nombre de séries insuffisant';
    END IF;

    -- Gérer condition 3 (moyenne examens blancs)
    SELECT AVG(examenScore) INTO v_scoreMoyen FROM (
        SELECT examenScore FROM Passer
        WHERE idEleve = NEW.idUtilisateur
        ORDER BY examenScore DESC LIMIT 4
    ) AS MeilleureNotes;

    IF v_scoreMoyen < 34 THEN
        SIGNAL SQLSTATE '10005' SET MESSAGE_TEXT = 'Garantie réussite : score examens blancs insuffisant';
    END IF;
END$$
DELIMITER ;
----

=== Travail à Faire

* **Question B.1.2**:
a) Analyser le corps du déclencheur et repérer les conditions qui ne sont pas ou mal implémentées.
b) Écrire le code source corrigé du déclencheur (uniquement les parties à modifier ou à ajouter).

* **Exercice Pratique**:
Écrivez des instructions `UPDATE` pour déclencher successivement chacun des messages d'erreur (SQLSTATE 10001, 10002, etc.).

== Partie 7 : Discussion - La "Défense en Profondeur" et ses Alternatives

=== Avantages
* **Cohérence Garantie** : L'action est exécutée *quelle que soit* l'application.
* **Atomicité** : Le trigger s'exécute dans la *même transaction*.
* **Audit Fiable**.

=== Inconvénients
* **Performance** : S'exécute à chaque événement.
* **Complexité** : "Logique Cachée".
* **Maintenance** difficile.

=== Alternatives
1.  **Contraintes (Constraints)**.
2.  **Logique Applicative**.
3.  **Procédures Stockées**.