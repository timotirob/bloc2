= TP5 : Procédures Stockées et Fonctions Utilisateur
Timothée Robert
:doctype: article
:encoding: utf-8
:lang: fr
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: rouge
:rouge-style: github


== Introduction

=== Objectifs

Les déclencheurs (_triggers_) sont des outils de base de données avancés, de nouveau mis en avant dans le référentiel du BTS SIO option SLAM. Ils constituent une solution de défense en profondeur côté serveur face aux menaces de compromission de données, d’injection de code malveillant, de vols ou d’accès non autorisé.

[IMPORTANT]
====
Le prérequis pour pouvoir étudier les déclencheurs est de connaître les procédures stockées et pour cela d’avoir des notions de Transact-SQL.
====

=== Rappels

La semaine dernière, nous avons vu les éléments essentiels du langage Transact-SQL :

* Instructions et blocs
* Variables : définition, `SET` et `SELECT`
* Boucles
* Conditions
* Séquencement (`BREAK` et `CONTINUE`)

---

== Transact-SQL : Les routines

=== Introduction

Les routines sont des blocs de code nommés, avec une partie schéma (dbo par défaut) et une partie nom, qui sont précompilés et stockés dans la base de données. Elles sont accessibles via des vues systèmes.

L’intérêt des routines en Transact-SQL est multiple :

* **Sécurité** renforcée
* **Intégrité** : certitude d’exécuter les traitements dans le bon ordre et dans des blocs cohérents.
* **Productivité** : réutilisation, modularité (développement en équipe), extensibilité.
* **Performance** : moins d’appels à la base de données.

Les routines sont divisées en 3 groupes :

.   **Procédures stockées** : Peuvent avoir des paramètres en entrée et en sortie. Utilisables via `EXEC`, dans des langages externes (C#, Java...) ou une autre procédure.
.   **Fonctions** : Appelées UDF (_User Defined Function_). Utilisables dans une instruction LMD (SELECT, INSERT, UPDATE, DELETE) ou dans une procédure stockée.
.   **Déclencheurs (Triggers)** : Routines qui s’exécutent en fonction d’un évènement donné sur un objet (INSERT, UPDATE...).

.Schéma des routines en Transact-SQL
image::routines_tsql.png[Les 3 types de routines : Procédures, Fonctions, Déclencheurs]

NOTE: Nous aborderons aujourd’hui les procédures et les fonctions. Les déclencheurs seront vus à compter de la semaine prochaine.


== Procédures stockées

=== Éléments de syntaxe

==== Syntaxe minimale
[source,sql]
----
CREATE PROCEDURE schema.Nom (Paramètres) AS
BEGIN
    -- Corps de la procédure
END
----

[NOTE]
====
Les paramètres peuvent être en entrée (par défaut) ou en sortie (en utilisant le mot-clé `OUTPUT`).
====

==== Syntaxe complète
Pour la syntaxe complète, référez-vous à la documentation officielle de Microsoft.

[WARNING]
====
**Terminologie** : Habituellement, une procédure ne retourne rien. En Transact-SQL, une procédure stockée *peut* retourner des valeurs via des paramètres `OUTPUT`, ce qui peut prêter à confusion.
====

=== Exemple

==== Définition de la procédure
[source,sql]
----
CREATE PROCEDURE EXEMPLE (@ENTREE VARCHAR(10) , @SORTIE VARCHAR(50) OUTPUT) AS
BEGIN
    -- ....
END;
----

==== Appel de la procédure
[source,sql]
----
DECLARE @VAL_SORTIE VARCHAR(50);
EXEC EXEMPLE 'TEST ENTRE' , @VAL_SORTIE OUTPUT ;
PRINT @VAL_SORTIE ;
----
NOTE: Lors de l'appel, on passe une valeur littérale pour le paramètre d'entrée, mais une variable pour le paramètre de sortie, car c'est la procédure qui va lui assigner une valeur.

=== Accès aux procédures stockées

Les procédures stockées sont accessibles dans la vue système `sys.procedures` et également dans la vue `sys.objects` avec le type `SQL_STORED_PROCEDURE`.

=== Interaction avec la base de données

==== Instructions INSERT
La syntaxe est similaire au SQL standard, mais utilise des variables Transact-SQL. Les transactions sont gérées avec `BEGIN TRANSACTION` et se terminent par un `COMMIT TRANSACTION` (validation) ou un `ROLLBACK TRANSACTION` (annulation).

.Exemple de INSERT en Transact-SQL
[source,sql]
----
BEGIN TRANSACTION;
DECLARE @nom_etudiant VARCHAR(50), @nb_heures INT, @nom_filiere VARCHAR(10);
SET @nom_etudiant = 'ROBERT';
SET @nb_heures = 1200;
SET @nom_filiere = 'UNIV P1';

INSERT INTO PROCS.FORMATIONELEVES VALUES(@nom_etudiant, @nb_heures, @nom_filiere);

COMMIT TRANSACTION;
----

==== Instructions UPDATE et DELETE
Le principe est identique à l'instruction `INSERT`, en utilisant des variables Transact-SQL.


== Fonctions Utilisateurs (UDF)

Une fonction utilisateur (UDF) peut être utilisée dans :

* Une instruction SQL LMD (Langage de Manipulation de Données)
* Une autre routine
* Un autre langage de programmation
* Une vue ou une vue indexée
* La définition d’une colonne ou une contrainte `CHECK`

=== Valeur de Retour

Une UDF retourne soit :

* Une **valeur unique** (fonction dite **scalaire**)
* Une **table** (un ensemble de lignes et de colonnes)

=== Limites de fonctionnalités
[CAUTION]
====
Une UDF **ne peut pas** :

* Mettre à jour une table ou une vue (`INSERT`, `DELETE`, `UPDATE`, `MERGE`).
* Appeler une procédure stockée.
* Contenir une transaction.

Le principe est donc qu’une procédure stockée peut contenir des fonctions, mais l’inverse n’est pas vrai.
====

=== Fonction scalaire

Une fonction scalaire retourne une valeur unique.

.Syntaxe minimale d'une fonction scalaire
[source,sql]
----
CREATE FUNCTION schema.Nom (Paramètres)
RETURNS type_de_donnees
AS
BEGIN
    -- Bloc d'instructions
    RETURN expression;
END
----
NOTE: La dernière instruction du bloc `BEGIN...END` doit toujours être un `RETURN`.

=== Obtenir des informations sur les UDF

La requête suivante permet de lister les UDF de la base de données courante.

[source,sql]
----
SELECT
    m.DEFINITION,
    o.TYPE
FROM
    SYS.SQL_MODULES AS m
INNER JOIN
    SYS.OBJECTS AS o ON m.OBJECT_ID = o.OBJECT_ID
WHERE
    o.type IN ('FN', 'IF', 'TF');
----

== Exercice 1 : Ma Première Procédure (Analyse de filière)

L'objectif est de transformer un script d'analyse simple en une procédure réutilisable, en y ajoutant progressivement des paramètres d'entrée et de sortie. Nous utiliserons la table `PROCS.FORMATIONELEVES`.

[source,sql]
----
include::scripts/005-Script création table FormationEleves.sql[]
----

=== Étape 1 : Création d'une procédure simple

Créez une procédure stockée nommée `CalculerMoyenneHeuresTotale` dans le schéma `PROCS`. Cette procédure ne prend aucun paramètre et doit simplement calculer et *afficher* (avec `PRINT`) le nombre d'heures de cours moyen de **tous** les élèves.

TIP: La structure de base est `CREATE PROCEDURE ... AS BEGIN ... END;`. N'oubliez pas d'exécuter la procédure avec `EXEC PROCS.CalculerMoyenneHeuresTotale;` pour la tester.

=== Étape 2 : Ajout d'un paramètre d'entrée

Modifiez la procédure (avec `CREATE OR ALTER PROCEDURE`) pour qu'elle s'appelle désormais `CalculerMoyenneHeuresParFiliere`.
Elle doit maintenant accepter un paramètre d'entrée `@filiere_code VARCHAR(10)`.
Le calcul de la moyenne ne se fera que pour les élèves de la filière passée en paramètre.

Testez-la avec différentes filières :
[source,sql]
----
EXEC PROCS.CalculerMoyenneHeuresParFiliere @filiere_code = 'SLAM ENC';
EXEC PROCS.CalculerMoyenneHeuresParFiliere @filiere_code = 'Ecole 42';
----

=== Étape 3 : Ajout d'un paramètre de sortie

La bonne pratique est qu'une routine de calcul ne doit pas faire d'affichage. Modifiez à nouveau la procédure pour qu'elle ne fasse plus de `PRINT`.
À la place, elle doit **retourner** le résultat via un paramètre de sortie `@moyenne_heures DECIMAL(8,2) OUTPUT`.

Le programme appelant se chargera de déclarer une variable pour récupérer ce résultat et de l'afficher.

NOTE: Un paramètre de sortie se déclare avec le mot-clé `OUTPUT` dans la signature de la procédure ET lors de son appel.

== Exercice 2 : Procédure avec Logique Conditionnelle (Validateur de mot de passe)

Créons un outil plus complexe : une procédure qui évalue la "force" d'un mot de passe selon des critères simples. C'est un excellent cas d'usage pour la logique `IF` et les fonctions de chaînes de caractères.

Créez une procédure `VerifierForceMotDePasse` avec :

* Un paramètre d'entrée : `@mot_de_passe VARCHAR(50)`
* Un paramètre de sortie : `@score_force INT OUTPUT`

La procédure doit calculer un score de la manière suivante :

* Le score de base est 0.
* **+1 point** si la longueur du mot de passe est d'au moins 8 caractères (`LEN`).
* **+1 point** s'il contient au moins un chiffre (utilisez `PATINDEX('%[0-9]%')`).
* **+1 point** s'il contient au moins une majuscule (utilisez `PATINDEX('%[A-Z]%')`).

Testez votre procédure avec plusieurs mots de passe pour vérifier que le score retourné est correct.

== Exercice 3 : Procédure "Rapport" (Le Capstone = dernière pierre)

Cet exercice de synthèse vise à créer une procédure qui retourne un rapport complet sur une filière. Elle combine agrégats, recherche de maximum et gestion de plusieurs paramètres de sortie.

Créez une procédure `EffectuerRapportFiliere` avec :

* Un paramètre d'entrée : `@filiere_code VARCHAR(10)`
* Trois paramètres de sortie :
** `@nombre_eleves INT OUTPUT`
** `@moyenne_heures DECIMAL(8,2) OUTPUT`
** `@meilleur_eleve VARCHAR(50) OUTPUT`

La procédure doit :

1. Calculer le nombre total d'élèves dans la filière demandée.
2. Calculer la moyenne d'heures de cours pour cette filière.
3. Trouver le nom de l'élève ayant le plus d'heures de cours dans cette filière.
4. Affecter ces trois résultats aux trois paramètres de sortie.

TIP: Pour trouver le meilleur élève, la méthode `SELECT TOP 1 ... ORDER BY NB_HEURES_COURS_INFO DESC` est la plus efficace.

== Exercice 4 (Optionnel) : Ma Première Fonction Scalaire (UDF)

Les procédures sont puissantes, mais ne peuvent pas être utilisées directement dans une requête `SELECT`. C'est là que les fonctions excellent.
Nous allons créer une fonction simple et pratique qui formate un nom complet.

Créez une fonction scalaire nommée `FormaterNomComplet` dans le schéma `PROCS`.

* Elle prend deux paramètres d'entrée : `@nom VARCHAR(50)` et `@prenom VARCHAR(50)`.
* Elle retourne (`RETURNS`) une chaîne de caractères `VARCHAR(101)`.
* La logique doit retourner le nom formaté comme suit : `NOM (en majuscules), Prénom`. Par exemple, `FormaterNomComplet('Robert', 'Timothée')` doit retourner `'ROBERT, Timothée'`.

Utilisez les fonctions `UPPER()` et la concaténation `+`.

Testez votre fonction directement dans une requête `SELECT` sur la table des élèves :
[source,sql]
----
SELECT
    PROCS.FormaterNomComplet(NOM_ELEVE, 'PrénomTest') AS NomFormate,
    NB_HEURES_COURS_INFO
FROM PROCS.FORMATIONELEVES;
----

