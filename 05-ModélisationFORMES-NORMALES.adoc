= RÃ©vision : DÃ©pendances Fonctionnelles et Formes Normales (FN)
:doctype: article
:encoding: utf-8
:lang: fr
:toc: left
:toc-title: Sommaire
:allow-uri-read:
:imagesdir: ./images

== ðŸŽ¯ Objectifs de la rÃ©vision
* Mieux apprÃ©hender le niveau de la modÃ©lisation relationnelle
* Comprendre la notion de **DÃ©pendance Fonctionnelle** (DF).
* MaÃ®triser les dÃ©finitions et les critÃ¨res de la **1Ã¨re, 2Ã¨me, 3Ã¨me Forme Normale** (1NF, 2NF, 3NF).
* MaÃ®triser la dÃ©finition et le critÃ¨re de la **Forme Normale de Boyce-Codd** (BCNF).
* Savoir appliquer la normalisation pour obtenir un ModÃ¨le Relationnel propre (jusqu'Ã  3NF/BCNF).

== ðŸ’¡ Fondements et Terminologie
Un modÃ¨le de donnÃ©es relationnel doit Ãªtre normalisÃ© pour Ã©liminer la redondance et les anomalies de mise Ã  jour (insertion, modification, suppression).

.Niveaux de modÃ©lisation (Conceptuel / Logique / Physique)
image::NiveauxModÃ©lisations.png[Niveaux de modÃ©lisation, width=600, align="center"]

=== DÃ©finition du modÃ¨le relationnel

Un modÃ¨le logique de donnÃ©es spÃ©cifiant un schÃ©ma pour une base de donnÃ©es relationnelle soit : les tables, les champs de chaque table et leurs propriÃ©tÃ©s, la clÃ© primaire des tables, les clÃ©s Ã©trangÃ¨res assurant les liaisons entre les tables et les contraintes dâ€™intÃ©gritÃ© portant sur ces liaisons

Pertinence du modÃ¨le relationnel:

* IndÃ©pendant du SGBD, tout en Ã©tant plus proche des tables
* Etape de vÃ©rification / validation modÃ¨le
* Typage et estimation volumÃ©trie de la base
* PrÃ©cisions sur les contraintes, notamment UNIQUE et CHECK

=== Vocabulaire

Le schÃ©ma suivant illustre les diffÃ©rents termes utilisÃ©s pour des mÃªmes notions selon le contexte:

.Des termes diffÃ©rents pour la mÃªme notion selon le contexte
image::Vocabulaire.png[Contextes, width=600, align="center"]

=== DÃ©pendance Fonctionnelle (DF)
Une dÃ©pendance fonctionnelle, notÃ©e DETERMINANT -> DEPENDANT, signifie que pour toute valeur de l'attribut ou du groupe d'attributs DETERMINANT (le *dÃ©terminant*), il existe une seule valeur correspondante pour l'attribut ou le groupe d'attributs DEPENDANT (le *dÃ©terminÃ©*).

* *Exemple :* `NumÃ©ro EmployÃ©` -> `Nom EmployÃ©`


=== DÃ©finition : ClÃ© Candidate et ClÃ© Primaire
Une **ClÃ© Candidate (CC)** est un ensemble minimal d'attributs qui dÃ©termine tous les autres attributs de la relation.

* *Minimal :* Si on enlÃ¨ve n'importe quel attribut de la clÃ© candidate, celle-ci n'est plus une clÃ©.
* La **ClÃ© Primaire (PK)** est la ClÃ© Candidate que le concepteur choisit pour identifier les enregistrements.

==== DepÃ©ndance fonctionnelle Ã©lÃ©mentaire

Une DF (Attribut1, Attribut2) -> DEPENDANT est Ã©lÃ©mentaire si
Attribut1 -> DEPENDANT nâ€™est pas DF ET
Attribut2 -> DEPENDANT nâ€™est pas DF

Permet de dÃ©tecter les problÃ¨mes de 2Ã¨me Forme Normale

Exemple (C. SOUTOU: demandez moi les scripts si vous ne les retrouvez pas): `( num_pilote,jour ) -> nb_heures_vol est Ã©lÃ©mentaire`

==== DepÃ©ndance fonctionnelle directe

Une DF DETERMINANT -> DEPENDANT est directe si elle ne peut pas Ãªtre dÃ©duite par transitivitÃ© câ€™est Ã  dire:

- DETERMINANT -> attributX nâ€™est pas DF OU BIEN
- AttributX -> DEPENDANT nâ€™est pas DF

Permet de dÃ©tecter les problÃ¨mes de 3Ã¨me Forme Normale

Exemple (C. SOUTOU): immatriculation aÃ©ronef -> nom du constructeur nâ€™est PAS directe car
immatriculation aÃ©ronef -> type avion est DIRECTE ET
Type avion -> nom constructeur est aussi DIRECTE


=== Niveau Logique
Le niveau logique se rapproche des tables tout en restant indÃ©pendant du SystÃ¨me de Gestion de Base de DonnÃ©es (SGBD). C'est Ã  ce niveau que les Formes Normales sont appliquÃ©es.

=== Principes de modÃ©lisation
Un modÃ¨le de donnÃ©es relationnel doit Ãªtre normalisÃ©
La notion de normalisation comporte plusieurs niveaux, appelÃ©s formes, que nous allons prÃ©senter successivement

Chaque forme normale permet de rÃ©soudre des problÃ¨mes de modÃ©lisation que posent un non respect de ces principes

== ðŸ¥‡ 1Ã¨re Forme Normale (1NF)


Une relation est en **1NF** si et seulement si:

1. Elle possÃ¨de au moins une clef
2. Tous ses attributs sont *atomiques* (indivisibles)
3. Aucun attribut n'est rÃ©pÃ©tÃ©


=== ProblÃ¨me typique

La relation ci-dessous est-elle en 1Ã¨re forme normale ? Si non, que faut-il faire ?

.ProblÃ¨me de 1Ã¨re Forme Normale
image::PB1NF.png[Contextes, width=600, align="center"]

=== Solution au problÃ¨me de multivaluation

La solution consiste Ã  ajouter des relations, c'est Ã  dire des tables.
Nous obtenons:

* une table Produit
* une table Couleurs
* une table d'association Coloris qui permet les combinaisons de produit et de couleur

.Solution au problÃ¨me de multivaluation
image::SOL1NF.png[Contextes, width=600, align="center"]


== ðŸ¥ˆ 2Ã¨me Forme Normale (2NF)


Une relation en **1NF** est en **2NF** si et seulement si:

*tout attribut non-clÃ© est en dÃ©pendance fonctionnelle complÃ¨te vis-Ã -vis de la clÃ© primaire*.


* *RÃ¨gle :* Il ne doit y avoir aucune **dÃ©pendance fonctionnelle partielle** de la clÃ© primaire vers un attribut non-clÃ©. (Concerne uniquement les relations avec une clÃ© primaire composÃ©e).

* Autre rÃ©daction: tout attribut non clef ne dÃ©pend pas dâ€™une partie de la clef

=== SchÃ©ma contre exemple

Le schÃ©ma ci dessous montre une relation (table) qui est en 1NF mais N'est PAS en 2NF:

.Relation pas en 2NF
image::SchemaNon2NF.png[Contextes, width=600, align="center"]

=== ProblÃ¨me typique (DÃ©pendance partielle)

Le schÃ©ma ci dessous n'est PAS en 2Ã¨me forme normale.

* Pourquoi ?
* Quel problÃ¨me cela pose t'il ?

.ProblÃ¨me de 2Ã¨me Forme Normale
image::PB2NF.png[Contextes, width=600, align="center"]


=== Solution au problÃ¨me de 2Ã¨me forme normale

==== Astuce et Ã  se rappeler
Les problÃ¨mes de forme normale concernent TOUJOURS une clef primaire composÃ©e (identifiant composÃ© de plusieurs colonnes)

==== Solution

On dÃ©place l'attribut Poids de la table d'association vers le Produit: le poids Ã©tant indÃ©pendant du Coloris on respecte ainsi la 2NF

.Solution au problÃ¨me de dÃ©pendance partielle
image::SOL2NF.png[Contextes, width=600, align="center"]

== ðŸ¥‰ 3Ã¨me Forme Normale (3NF)


Une relation en **2NF** est en **3NF** si et seulement si *aucun attribut non-clÃ© n'est en dÃ©pendance fonctionnelle transitive vis-Ã -vis de la clÃ© primaire*.

* *RÃ¨gle :* Il ne doit y avoir aucune dÃ©pendance d'un attribut non-clÃ© vers un autre attribut non-clÃ©.

* 2Ã¨me rÃ©daction possible: tout attribut non clef ne dÃ©pend pas dâ€™un autre attribut non clef

* 3Ã¨me rÃ©daction possible: tout attribut n'appartenant pas Ã  la clÃ© ne dÃ©pend pas transitivement de la clÃ©

Si A -> B et B -> C et que A est la clÃ©, alors il y a une **dÃ©pendance transitive** A -> C via B.

NOTE: La dÃ©pendance transitive (A -> B -> C) est directement liÃ©e Ã  l'**Axiome de TransitivitÃ© d'Armstrong**. C'est le moyen thÃ©orique d'expliquer pourquoi, si la clÃ© A dÃ©termine un attribut non-clÃ© B, et que B dÃ©termine un autre non-clÃ© C, la connaissance de A suffit Ã  dÃ©terminer C via B, crÃ©ant la redondance et violant la 3NF.



=== SchÃ©ma contre exemple

Le schÃ©ma ci dessous montre une relation (table) qui est en 2NF mais N'est PAS en 3NF:

.Relation pas en 3NF
image::SchemaNon3NF.png[Contextes, width=600, align="center"]

=== Illustration

Ã€ titre d'illustration, la relation:

`VOITURE (NV, MARQUE, TYPE, PUISSANCE, COULEUR)`

n'est pas en troisiÃ¨me forme normale.

En effet, l'attribut non-clÃ© TYPE dÃ©termine MARQUE et aussi PUISSANCE.

Cette relation peut Ãªtre dÃ©composÃ©e en deux relations:

`VOITURE (NV, TYPE, COULEUR)`

`MODELE (TYPE, MARQUE, PUISSANCE)`.

=== ProblÃ¨me typique

Le schÃ©ma ci dessous n'est PAS en 3Ã¨me forme normale.

* Pourquoi ?
* Quel problÃ¨me cela pose t'il ?

.ProblÃ¨me de 3Ã¨me Forme Normale
image::PB3NF.png[Contextes, width=600, align="center"]


=== Solution au problÃ¨me de 3Ã¨me forme normale

==== Astuce et Ã  se rappeler
Les problÃ¨mes de forme normale concernent gÃ©nÃ©ralement un attribut qui doit Ãªtre placÃ© dans une autre relation (table) qui est Ã  un niveau plus "agrÃ©gÃ©"

==== Solution

On dÃ©place la Marque dans une autre relation (table)

.Solution au problÃ¨me de dÃ©pendance transitive
image::SOL3NF.png[Contextes, width=600, align="center"]


== ðŸ‘‘ Forme Normale de Boyce-Codd (BCNF)


Une relation est en **BCNF** si et seulement si elle est en **3NF** *ET* si toute dÃ©pendance fonctionnelle non triviale A -> B vÃ©rifie que A est une **clÃ© candidate** pour la relation.

* *RÃ¨gle simplifiÃ©e :* Le seul dÃ©terminant (partie gauche de la DF) est une clÃ© candidate (aucune dÃ©pendance vers une partie de la clef ne doit exister)

=== SchÃ©ma contre exemple

Le schÃ©ma ci dessous montre une relation (table) qui est en 3NF mais N'est PAS en BCNF:

.Relation pas en BCNF
image::SchemaNonBCNF.png[Contextes, width=600, align="center"]


=== Cas spÃ©cial : 3NF vs BCNF
Une relation est en 3NF, mais pas en BCNF, lorsque l'on a une DF non triviale A -> B oÃ¹ A est un dÃ©terminant non-clÃ©, *mais* A fait partie d'une clÃ© candidate.

==== DÃ©finition du Contexte et des Contraintes

Ceci est le cas le plus difficile : la relation ne contient **aucun attribut non-clÃ©**, ce qui satisfait *trivialement* la 3Ã¨me Forme Normale, mais elle est dÃ©composable car un dÃ©terminant n'est pas une clÃ© candidate.

==== Relation Initiale
Nous gÃ©rons les aides-correcteurs rattachÃ©s aux cours et aux Ã©tudiants.

`R = EXAMEN ([.underline]#Ã‰tudiantID#, CoursID, AideCorrecteur)`

==== DÃ©pendances Fonctionnelles (DF)

.Tableau de l'Exercice : DÃ©pendances Fonctionnelles (DF)
[cols="3,6,3", options="header"]
|===
| DF | Justification | DÃ©terminant
| (F1) `Ã‰tudiantID, CoursID` -> `AideCorrecteur` | La paire Ã‰tudiant/Cours a un seul Aide-Correcteur. | {Ã‰tudiantID, CoursID}
| (F2) `AideCorrecteur` -> `CoursID` | Un Aide-Correcteur ne s'occupe que d'un seul cours (SpÃ©cialisation). | {AideCorrecteur}
| (F3) `Ã‰tudiantID, AideCorrecteur` -> `CoursID` | Un Ã©tudiant, pour un Aide-Correcteur donnÃ©, n'est inscrit qu'Ã  un seul cours (DÃ©rivÃ© de F1 et F2). | {Ã‰tudiantID, AideCorrecteur}
|===

==== ClÃ©s Candidates (CC)

.Tableau : ClÃ©s Candidates (CC) de la Relation EXAMEN
[cols="5,5", options="header"]
|===
| ClÃ© Candidate | Justification
| `K_1 = {Ã‰tudiantID, CoursID}` | DÃ©termine tous les attributs (via F1).
| `K_2 = {Ã‰tudiantID, AideCorrecteur}` | DÃ©termine tous les attributs (via F2 et F3).
|===

==== Analyse des Formes Normales

===== Verdict 3NF
* **Attributs Non-ClÃ©s :** Aucun. Tous les attributs font partie d'au moins une ClÃ© Candidate.
* **Conclusion 3NF :** La rÃ¨gle 3NF (qui ne s'applique qu'aux Attributs Non-ClÃ©s) est **RESPECTÃ‰E** par dÃ©faut.

===== Verdict BCNF
La rÃ¨gle BCNF est violÃ©e si un dÃ©terminant A n'est **PAS** une ClÃ© Candidate (CC).

* **DF Violatrice :** (F2) `AideCorrecteur` -> `CoursID`
* **DÃ©terminant :** `AideCorrecteur`
* **Est-ce une CC ?** Non. (`AideCorrecteur` ne dÃ©termine pas `Ã‰tudiantID`).
* **Conclusion BCNF :** La relation est **NON BCNF**.

**Le ProblÃ¨me :** L'information de spÃ©cialisation de l'aide-correcteur (F2) est stockÃ©e de maniÃ¨re redondante dans chaque enregistrement d'Ã©tudiant.

==== DÃ©composition en BCNF

Nous dÃ©composons en isolant la DF problÃ©matique (F2) du reste de la relation.

.DÃ©composition Finale en BCNF
[cols="3,3,4", options="header"]
|===
| Relation BCNF | ClÃ© Primaire (PK) | Attributs
| **AIDE_COURS** | `_AideCorrecteur_` | `AideCorrecteur`, `CoursID`
| **INSCRIPTION_ETUDIANT** | `_Ã‰tudiantID, AideCorrecteur_` | `Ã‰tudiantID`, `AideCorrecteur` (FK)
|===

.DÃ©tail de la violation de BCNF
[cols="3,3", options="header"]
|===
| DÃ©terminant problÃ©matique | RÃ¨gle BCNF violÃ©e
| {AideCorrecteur}  | Le dÃ©terminant {AideCorrecteur} n'est pas une clÃ© candidate et dÃ©termine un autre attribut.
|===

== ðŸ“ Exercices de ModÃ©lisation
=== MÃ©thodologie
Pour les exercices de normalisation on utilise une **mÃ©thodologie de dÃ©composition**.

Cette dÃ©composition doit garantir deux propriÃ©tÃ©s essentielles :

1. **DÃ©composition sans perte d'information** (Lossless Join Decomposition) : La jointure des relations dÃ©composÃ©es doit redonner la relation initiale (ce qui est toujours le cas si on inclut la clÃ© de la DF extraite).

2. **PrÃ©servation des dÃ©pendances** (Dependency Preservation) : Toutes les DF de la relation originale doivent Ãªtre prÃ©servÃ©es dans les nouvelles relations (ou par composition).

=== Exercice 1 : Professions

La relation ci dessous est elle en 1Ã¨re forme Normale. Si non, que changer ?

.Profession
image::Exo1.png[Contextes, width=600, align="center"]

=== Exercice 2 : Fournisseurs

Soit la table suivante:

`Fournisseur( nom, article, adresse, prix)` .

La clef primaire est composÃ©e, de  nom et article

1. Quelles sont les dÃ©pendances fonctionnelles ?

2. La table Fournisseur est elle en 2Ã¨me forme normale ?

3. Si non, quelles corrections effectuer pour Ãªtre en 2 FN ?

=== Exercice 3 : Vin (Gardarin)

Soit la table, concernant le domaine du vin, suivante:

`Localisation( cru, pays, rÃ©gion, qualitÃ©)` .

La clef primaire est composÃ©e, de  `cru et pays`

Les DF sont les suivantes:

* `(Cru, pays) -> RÃ©gion`
* `(Cru, pays) -> QualitÃ©`   (trÃ¨s franchouillard)
* `RÃ©gion -> Pays`

Exemple de cru: Chablis (on en trouve en France dans rÃ©gion Beaujolais et aux USA rÃ©gion Californie)

1. Est elle en BCNF ?

2. Si non, comment faire pour respecter la BCNF ?

=== Exercice 4 :  Recette de cuisine (R. Grin)

On souhaite crÃ©er une BDD de recette de cuisine:

* Une recette est identifiÃ©e par son numÃ©ro.
* Elle a un nom et un type particulier (soupe, entrÃ©e, dessert, ...).
* Elle utilise un ou plusieurs ingrÃ©dients (carottes, viande de boeuf, poivre, ...).
* Un ingrÃ©dient est identifiÃ© par son numÃ©ro et a un nom.
* Pour chaque ingrÃ©dient dans une recette, on prÃ©cisera sa quantitÃ©.

1. Donner la liste des DF (dÃ©pendances fonctionnelles) pour la relation `R = {NumR, NomR,TypeR, NumI, NomI, Qte}`
2. Proposer une dÃ©composition de R qui respecte les FN
3. Critiquer la dÃ©composition dÃ©composition suivante:

`R1 = (NumR, NomR,TypeR)`

`R2 = (NumR, NumI, Qte)`

`R3 = (NumI, NomI)`

`R4 = (NumR, Ustensile)`


=== Exercice 5 : Ligne de Commande

Une commande est composÃ©e de plusieurs lignes de commande avec un produit associÃ©.
Soit la relation suivante :

*Relation :* `LigneCommande (NumÃ©ro de commande, NumÃ©ro de produit, Description, Prix, QuantitÃ©)`

a.	Donnez les dÃ©pendances fonctionnelles (DF) de la relation
b.	Proposez une clef pour cette relation
c.	A quelle forme normale se conforme la relation ?
d.	Critiquez


=== Exercice 6 : EmployÃ©

Pour chaque relation, donnez la clef et ensuite catÃ©gorisez les en:

* non normalisÃ©,
* 1NF,
* 2NF,
* 3NF:
a.	`EmployÃ©(numÃ©ro employÃ©, nom employÃ©, code emploi)` avec les DF suivantes :
- `NumÃ©ro employÃ© -> nom employÃ©`
- `NumÃ©ro employÃ© -> code emploi`

b.	`EmployÃ©(numÃ©ro employÃ©, nom employÃ©, (code emploi, annÃ©es embauchÃ©))` avec les DF suivantes :
- `NumÃ©ro employÃ© -> nom employÃ©`
- `(NumÃ©ro employÃ©, code emploi) -> annÃ©es embauchÃ©`

c.	`EmployÃ©(numÃ©ro employÃ©, nom employÃ©, code emploi, libellÃ© emploi)` avec les DF suivantes :
- `NumÃ©ro employÃ© -> nom employÃ©`
- `NumÃ©ro employÃ© -> code emploi`
- `Code emploi-> libellÃ© emploi`

d.	`EmployÃ©(numÃ©ro employÃ©, nom employÃ©, projet, nombre heures travaillÃ©)` avec les DF suivantes :
- `NumÃ©ro employÃ© -> nom employÃ©`
- `NumÃ©ro employÃ©, projet -> nombre heures travaillÃ©`


=== Exercice 7 : Bon de Commande

Soit le document suivant qui reprÃ©sente un bon de commande. Produisez le modÃ¨le relationnel correspondant en **3Ã¨me forme normale**

.Bon de commande
image::ExoBonCommande.png[Bon commande, width=600, align="center"]


=== Exercice 8 : Groupe Musical

HypothÃ¨ses : un groupe musical est associÃ© Ã  un genre de musique. Un groupe ne fait pas plus dâ€™une sÃ©rie de concert dans la mÃªme salle pour une mÃªme annÃ©e.

1. Soit lâ€™extrait de schÃ©ma relationnel en extension suivant :

.Groupe concert
image::GroupeMusique1.png[Concert 1, width=600, align="center"]

* La relation est-elle en 2NF (2Ã¨me forme normale) ?
* en 3NF ?
* DÃ©terminez le(s) DF et la clef pour justifier la rÃ©ponse.

2. La dynamique des concerts et des groupes a changÃ©: voici le nouvel extrait

.Groupe concert modifiÃ©
image::GroupeMusique2.png[Concert 1, width=600, align="center"]

* La relation modifiÃ©e est-elle en 2NF ?
* en 3NF ?

=== Exercice 9 : Transport Maritime

Soit la relation suivante :

`TransportMaritime(bateau, type bateau, identifiant voyage, cargaison, port de destination, date arrivÃ©e)`

ConsidÃ©rant les DF suivantes :

* `Bateau -> type bateau`
* `Identifiant voyage -> (bateau, cargaison)`
* `(Bateau, date arrivÃ©e) -> (identifiant voyage, port de destination)`

Questions:

1.	Quelles sont les clefs possibles de la relation ?
2.	Proposez une modÃ©lisation qui respecte les 3 premiÃ¨res forme normale et BCNF

=== Exercice 10 : Gestion des Postes Informatiques (focus 3NF)

Un Ã©tablissement gÃ¨re son parc informatique au niveau du poste.

* Chaque Poste est identifiÃ© par son NumÃ©ro de SÃ©rie (NumSÃ©rie).
* Le poste est attribuÃ© Ã  un Utilisateur (ID_Utilisateur).
* L'utilisateur est rattachÃ© Ã  un Service (CodeService).
* Chaque service a un Nom de Service unique et est gÃ©rÃ© par un Chef de Service (NomChef).

Relation Initiale :

- `Parc (NumSÃ©rie, ID_Utilisateur, NomUtilisateur, CodeService, NomService, NomChef)`
- DÃ©pendances Fonctionnelles (DF) :
* `(F1) NumSÃ©rie -> (ID_Utilisateur, NomUtilisateur, CodeService)`
* `(F2) ID_Utilisateur -> (NomUtilisateur, CodeService)`
* `(F3) CodeService -> (NomService, NomChef)`

Questions :
1. DÃ©terminez la clÃ© primaire de la relation Parc.
2. Quelle est la forme normale maximale atteinte par la relation Parc ?
3. Justifiez votre rÃ©ponse en identifiant les dÃ©pendances problÃ©matiques.
4. Proposez un modÃ¨le relationnel en 3Ã¨me Forme Normale (3NF) pour Ã©viter les anomalies.

(Point clÃ© : La dÃ©pendance transitive `NumSÃ©rie -> CodeService -> (NomService,NomChef)` viole la 3NF.)

=== Exercice 11 : Gestion des Inscriptions aux Modules (focus BCNF)

Une association de formation gÃ¨re les inscriptions aux modules.

* Un Participant est identifiÃ© par son ID_Participant.
* Un Module est identifiÃ© par son CodeModule.
* L'inscription lie un participant Ã  un module (DateInscription).
* Chaque module est enseignÃ© par un Formateur (NomFormateur).
* Chaque formateur a une SpÃ©cialitÃ© unique.

* **Contrainte spÃ©cifique** : Bien que plusieurs formateurs puissent enseigner un module, pour un module donnÃ©, le CodeModule dÃ©termine le NomFormateur principal.

* Et un formateur est rattachÃ© Ã  une seule spÃ©cialitÃ©.

[.underline]#Relation Initiale# : `Inscription (ID_Participant, CodeModule, DateInscription, NomFormateur, SpÃ©cialitÃ©)`

[.underline]#DÃ©pendances Fonctionnelles (DF)#  :
- (F1) `(ID_Participant, CodeModule) -> DateInscription, NomFormateur, SpÃ©cialitÃ©`
- (F2) `NomFormateur $\to$ SpÃ©cialitÃ©`
- (F3) `CodeModule $\to$ NomFormateur`

[.underline]#Questions# :

1. DÃ©terminez la clÃ© primaire de la relation Inscription.
2. Identifiez si la relation est en BCNF.
(Indice : le dÃ©terminant de F3 n'est pas une clÃ© candidate).

3. DÃ©composez la relation en un modÃ¨le relationnel qui respecte la Forme Normale de Boyce-Codd (BCNF).

(Point clÃ© : La dÃ©pendance `CodeModule -> NomFormateur` est une dÃ©pendance entre un non-clÃ© (CodeModule est non-clÃ© dans la clÃ© principale) et un autre non-clÃ© (NomFormateur), ce qui est une violation de BCNF. Il faut extraire l'entitÃ© MODULE et l'entitÃ© FORMATEUR)

== ðŸ§‘â€ðŸ’» Exercice Type Ã‰tude de Cas : Normalisation UML (2NF et 3NF)

Cet exercice vise Ã  appliquer les rÃ¨gles de normalisation pour justifier les modifications apportÃ©es Ã  un modÃ¨le de classes UML initial.

L'objectif est de passer d'un modÃ¨le fautif Ã  un ModÃ¨le de Classes sain qui respecte la 3Ã¨me Forme Normale.

=== 1. Contexte : Gestion des Commandes Fournisseurs

Une entreprise gÃ¨re ses achats. Une **Commande** est passÃ©e Ã  un **Fournisseur** et contient plusieurs **Lignes de Commande** pour divers **Articles**.

=== 2. Diagramme de Classes UML Initial

Le modÃ¨le UML initial est prÃ©sentÃ© ci-dessous. Notez que certains attributs sont placÃ©s dans des classes inappropriÃ©es, crÃ©ant des anomalies :

[plantuml, uml-fautif, svg]
----
skinparam ClassAttributeIconSize 0

class Fournisseur {
    + idFournisseur (PK)
    -- Informations Fournisseur --
    + nom
    + categorie
    + RemiseMax
}

class LigneCommande {
    + idCommande (PK, FK vers Commande)
    + noLigne (PK)
    + codeArticle (FK vers Article)
    -- DÃ©tails de la ligne --
    + Quantite
    + PrixUnitaire           // ProblÃ¨me 1 : dÃ©pend de codeArticle (partie de la clÃ©)
    + NomCategorieArticle  // ProblÃ¨me 1 : dÃ©pend de codeArticle
    + NomFournisseur       // ProblÃ¨me 2 : redondance
}

class Commande {
    + idCommande (PK)
    + DateCommande
    + NomFournisseur       // ProblÃ¨me 2 : redondance / DF transitive
}

Commande "1" --> "N" LigneCommande : contient

Fournisseur "1" <-- "N" Commande : passe
----

=== 3. Questions d'Analyse (Justification par les Formes Normales)

1.  **Violation de la 2NF :** Dans la classe `LigneCommande`, la clÃ© primaire est composite : {`idCommande`, `noLigne`}. Cependant, les attributs `PrixUnitaire` et `NomCategorieArticle` dÃ©pendent uniquement de l'attribut `codeArticle`, qui n'est qu'une **partie de la clÃ©**.
* Quelle **rÃ¨gle des Formes Normales** est violÃ©e par cette situation ?
* Quelle nouvelle **classe UML** doit Ãªtre crÃ©Ã©e pour isoler ces attributs et rÃ©soudre la violation, et quelle sera sa clÃ© primaire ?

2.  **Violation de la 3NF :** Dans la classe `Commande`, l'attribut `NomFournisseur` est stockÃ©, bien que la commande soit dÃ©jÃ  liÃ©e au `Fournisseur` via une association. Ce nom est Ã©galement stockÃ© dans la classe `Fournisseur`.
* Expliquez pourquoi cette redondance viole la **3Ã¨me Forme Normale (3NF)** et comment cela se traduit en termes d'anomalies (insertion, suppression, modification).
* Quelle est la modification Ã  apporter Ã  la classe `Commande` pour respecter la 3NF ?

3.  **ModÃ¨le Final NormalisÃ© :** En intÃ©grant les modifications justifiÃ©es par la 2NF et la 3NF, proposez le **Diagramme de Classes UML final** (en PlantUML).

